dvr: {
    host = "10.225.142.36"; #海康dvr地址
    port = 8000;            #海康dvr端口
    username = "admin";     #海康dvr用户名
    password = "sd20130419";#海康dvr密码
    name = "mock" # 等于mock_haikang时读取本地视频(必须是mp4格式)
};

# 数据库配置，不配置不会连接写入据库
db: {
    host = "localhost";     #mysql地址
    port = 3306;            #mysql端口
    username = "root";      #mysql用户名
    password = "123456";    #mysql密码
    database = "vehicle_detection"; #数据库，主程序不会创建，事先运行scrpit/table.sql创建
    encoding = "utf8"       #数据库编码，一般不改动
};

channels = ( #摄像机，可重复多个
    {
        id = 35;
        name = "camera01";
        mock_videos = "/video/1/";    #mock模式下读取的文件，mock模式必须填
        mock_labels = "/video/1/";  #mock模式下输出的文件，选填
        mock_fps = 25; #mock模式下读取文件的fps，选填，不填则用视频本身的fps
        config = "low"; #配置名称，与config配置中对应
        regions = (
                {
                    name = "camera0100";
                    region = ([304, 0], [0, 399], [373, 446], [585, 0]);
                },
                {
                    name = "camera0101";
                    region = ([835, 87], [843, 472], [1274, 484], [1142, 72]);
                }
        );
        type = "gate";  #摄像头类型，"gate","station"
        in_orientation = "toleft";  #进站口方向, "toleft","toright"
    }
);

config = (  #配置，可重复多个
    {
        name = "high";  #配置名称，与摄像机中的config对应
        mod = 25;       #取样帧率，即每mod帧取一帧计算，其余帧忽略
        
        model = (       #模型匹配规则，当前有ocr，cmt，location三种，是帧结果与历史记录匹配的规则，要注意先后顺序
            {   
                name = "ocr";   #ocr
                miss_count = 1; #允许车牌有miss_count位错误
            },
            {
                name = "cmt";   #cmt
                match_count = 2;    #color/type/make中需要匹配的数目
            },
            {
                name = "location";  #location
                threshold = 50;     #两者距离的最大值，超过则认为匹配失败，与取样帧率和车速有关
            }
        )
        
        stay_count = 3; #停留stay_count帧，进行一次ocr与cmt更新
        out_count = 2;  #未在区域内检测到out_count次，则被任务是OUT
    },
    {
        name = "low";
        mod = 25;
        video = 
            {        
                write_original = true;    
                write_debug = true;   
                path = "/video";   
                keep = 3;  
            }
        model = (
            {
                name = "location";
                threshold = 30;
            },
            {
                name = "cmt";
                match_count = 2;
            },
            {   
                name = "ocr";
                miss_count = 1;
            }
        )

        stay_count = 8;
        out_count = 3;
        on_gpu = false;
    }
)

model: {
    vehicle: {
        path = "/models/vehicle_detection/frozen_inference_graph.pb";#模型位置
        inputs = ["image_tensor:0"];    #模型输入，固定，不可修改
        outputs = ["detection_boxes:0", "detection_scores:0", "detection_classes:0", "num_detections:0"];#模型输出，固定，不可修改
        threshold = 0.3;    #车辆阈值，超过该值则认为是车辆区域
        # device = "/cpu:0";    #模型运行的设备，如 "/cpu:0", "/gpu:0", "/cpu:1"
        # dbgflag = true;    #是否输出模型tf-debugger信息
        # devicelogFlag = true;    #是否输出模型各结点设备信息
    };

    license: {
        path = "/models/plate_detection/faster_rcnn_plate_graph.pb";#模型位置
        inputs = ["image_tensor:0"];#模型输入，固定，不可修改
        outputs = ["detection_boxes:0", "detection_scores:0", "detection_classes:0", "num_detections:0"];#模型输出，固定，不可修改
        threshold = 0.2;    #车牌阈值
        # device = "/cpu:0";
    };

    ocr: {
        path = "/models/plate_recognition/ocr_1029_753000s.model";
        inputs = ["features:0"];
        outputs = ["prediction:0"];
        width = 224;    #车牌宽高，固定，不可修改
        height = 36;
        # device = "/cpu:0";
    };

    cmt: {
        path = "/models/color_make_type/simple_frozen_inference_graph_1_3.pb"
        inputs = ["features:0"];
        outputs = ["prediction_color:0", "prediction_make:0", "prediction_type:0"];
        width = 212;
        height = 212;
        # device = "/cpu:0";
    }
};
